from __future__ import annotations
from typing import List
from .base import Detector
from ..analyzers.base import ParsedDocument
from ..config import ScanConfig
from ..report import Finding
from ..enums import ThreatID, Severity


class HiddenTextDetector(Detector):
    name = "hidden_text"

    def run(self, doc: ParsedDocument, config: ScanConfig) -> List[Finding]:
        if not config.enable_hidden_text:
            return []

        findings = []

        # 1. Metadata-based Hidden Text (Populated by analyzers like python-docx)
        # Analyzers should normalize "hidden" content into standardized metadata keys
        hidden_content = []

        # Check DOCX specific hidden metadata
        if doc.docx and "hidden_text" in doc.docx:
            val = doc.docx["hidden_text"]
            if val:
                if isinstance(val, list):
                    hidden_content.extend(val)
                elif isinstance(val, str):
                    hidden_content.append(val)

        # Check abstract metadata
        if doc.metadata and "hidden_text" in doc.metadata:
            val = doc.metadata["hidden_text"]
            if val:
                if isinstance(val, list):
                    hidden_content.extend(val)
                elif isinstance(val, str):
                    hidden_content.append(val)

        # Deduplicate
        hidden_content = list(set(hidden_content))

        # Common watermark phrases to ignore if allow_hidden_watermarks is True
        WATERMARK_ALLOWLIST = [
            "confidential",
            "draft",
            "internal use only",
            "property of",
            "do not copy",
            "watermark",
            "generated by",
            "copyright",
            "proprietary",
            "trade secret",
            "licensed to",
        ]

        for content in hidden_content:
            if not content.strip():
                continue

            # Smart Watermark Bypass
            if config.allow_hidden_watermarks:
                content_lower = content.lower()
                if any(phrase in content_lower for phrase in WATERMARK_ALLOWLIST):
                    continue

            # If the hidden text is substantial, flag it
            if len(content) > 50:  # Ignore tiny artifacts
                findings.append(
                    Finding(
                        # Hidden text is a form of obfuscation/evasion
                        threat_id=ThreatID.T3_OBFUSCATION,
                        severity=Severity.HIGH,
                        title="Hidden Text Detected",
                        explain=(
                            "Found significant amount of text marked as hidden "
                            "(e.g., invisible font, zero size)."
                        ),
                        evidence={"snippet": content[:100], "length": len(content)},
                        module=self.name,
                        confidence=0.9,
                    )
                )

        # 2. Heuristic: Text vs Visual Length (if available from PDF structure)
        # This is harder to do without rendering info,
        # but we can placeholder for future layout-analysis checks.

        return findings
